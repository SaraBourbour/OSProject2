#################################################
# README
#
# Author: Hunter Lang
# Project: 2, hsh (Hunter Shell)
# Class: Operating Systems
# Due: First deliverable,  10/03/13
# Due: Second deliverable, 10/10/13
# Due: Final deliverable,  10/17/13
#
#################################################

-------------------------------------------------
Contents
-------------------------------------------------

File: README
	This readme

Folder: OS-Project-Shell
	This is used for tracking the project using Xcode,
	not fully part of the project

Excel Sheet: TestResults
	This file is a spreadsheet prepared by me to help
	me keep track of what features I feel are complete
	and make sure that I hit the requirements
	
Folder: src
	Where all the source code is contained
	
File: src/builtins.h
	Header file for builtins.cpp, also referenced in 
	shell.cpp. Defines the built in functions of the
	shell, and also defines error code constants, as
	well as a switch to turn on low level debugging.
	
File: src/builtins.cpp
	Implementations for the functions defined in
	builtins.h
	
File: src/Makefile
	Makefile to build the project, supports two targets:
	all and clean. All (or none) builds the project from
	scratch, clean removes the executable

File: src/MyShell
	The executable generated by the calling `make'. Runs
	the actual shell program
	
File: src/shell.cpp
	Entry point for the shell program. Defines shell
	functions and also handles the history persistence.
	
	
Note:
	When executing this shell, it will place a file at
	~/.history to handle the persistence of the history.
	
-------------------------------------------------
Extra Features
-------------------------------------------------

-- Intermidate one --

1. Invoking `cd' without arguments will take the user to
	the path specified by $HOME.
	
2. `cd -' Will take the user to the previous directory.
	
3. I spent a LOT of time testing this project, therefore
	there is a switch in builtins.h to turn on a very
	verbose set of debug statements. Use it if you're
	curious.
	EDIT: This now is based upon printf and uses a compiler
	flag to turn on debugging. See 8 for more info.
	
4. I tested compatibility of this shell on both BSD based
	Unix, and Ubuntu Linux distributions, and works on
	both systems.
	
5. This shell uses a multiline prompt, that way the pwd
	can get massive and not be a problem.
	
6. The end of the prompt "lc: #" specifies the return code
	of the last command ran.

7. There is a greeting to the shell when it first starts,
	similar to other shells. I did this just for fun.
	
-- Intermediate two --

8. Shell supports (theoretically) infinite pipes. As long
	as you have the memory.

9. Makefile based debugging activation. Run `make debug' if you
	want to see verbose output.
	
-- Final Submission -- 

- Nothing neat to add this submission :(


-------------------------------------------------
Misc
-------------------------------------------------

For deliverable 1, I spent about 13 hours on it (mostly 
testing). It should	be rather solid of a shell now though.

For deliverable 2, I spent about 14 hours on the new features.
A lot of this time was making all the debugging not be in the way,
but also still be super useful.

For the final deliverable, I only spent about 4 hours. This
is super surprising to me. Maybe I just spent enough time making 
this final easy in the earlier deliverables.